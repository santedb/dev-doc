# 3.0 Releases

Version 3.0 of the SanteDB iCDR, dCDR and related solutions (SanteGuard and SanteMPI) represent a large series of changes from the 2.2x series. Some of the changes have been incorporated from our Version 3 [Roadmap](../../product-overview/santesuite-products/version-3.x-roadmap.md).

## Refactored Persistence Layer

The larges and perhaps most impactful change in the version 3.0 is a complete refactoring of the entire persistence layer in SanteDB. This refactoring has allowed the SanteDB 3.0 version not only to use the database much more efficiently, but allows callers on the REST APIs to exert more control over how data is loaded.

### Pipeline Loading of Results

The new persistence layer interfaces which load data to/from a data source now return an instance of `IQueryResultSet`. This is a delay expanded IEnumerable. Whenever a sort is applied, or a key is selected a new instance of IQueryResultSet is wrapped around the original. The database command is only executed when data is read from the reader. This also cleans up the calling structure, for example, in version 2.0 to determine if a record exists or to select a single field:

```csharp
var exists = persistence.Find(o=>o.UserName == "BOB", 0, 1, AuthenticationContext.SystemPrincipal).Any();

// Executed SQL:
// SELECT * FROM SEC_USR_TBL WHERE USR_NAME = 'BOB' OFFSET 0 LIMIT 1;

var key = persistence.Find(o=>o.UserName == "BOB", 0, 1, AuthenticationContext.SystemPrincipal).FirstOrDefault(o=>o.Key);
// Executed SQL:
// SELECT * FROM SEC_USR_TBL WHERE USR_NAME = 'BOB' OFFSET 0 LIMIT 1;
```

This pattern forced the persistence layer to load the object just to determine a detection.

In the new pattern this is now alleviated with IQueryResultSet:

```csharp
var resultSet = persistence.Find(o=>o.UserName == "BOB", AuthenticationContext.SystemPrincipal);

// No SQL is executed

var exists = resultSet.Any();

// SQL Executed:
// SELECT EXISTS 1 FROM SEC_USR_TBL WHERE USR_NAME = "BOB";

var key = resultSet.Select(o=>o.Key).FirstOrDefault();

// SQL Executed:
// SELECT SEC_USR_ID FROM SEC_USR_TBL WHERE USR_NAME = "BOB" LIMIT 1;
```

### Client Controlled Data Loading Strategies

Callers may also instruct to the data persistence layer the type of load strategy to be used when loading data from the database depending on the intended use of the data.

Data load strategies are:

* QuickLoad - Load only core properties, no related entities
* SyncLoad - Load only properties which are needed for synchronization
* FullLoad - Load all properties directly from the data persistence layer

Loading stratgies are controlled by the `DataPersistenceContext` :

```csharp
using(DataPersistenceContext.Create(LoadStrategy.QuickLoad)) {
   // Any data events here will only load core properties#
}
```

This method can also be used to control the way that data is deleted from the database.

### Harmonization of Persistence Providers

3.0 introduces new persistence provider which have allowed us to harmonize the dCDR and iCDR persistence layers into a common framework. This means that the iCDR can be run on SQLite, or the dCDR can be run on PostgreSQL!

## Refactoring of OAUTH Infrastructure

The OAUTH infrastructure has been refactored completed to better adhere to OpenID concepts. This refactoring includes:

* Separation of the grant type into extendable implementations so users can create custom grant flows or override the SanteDB flows more readily
* Separation of token serialization, and encoding allowing for more robust access and identity token passing
* Implementation of standardized MFA secret generation using time and hash based one time passwords.

## Harmonization of the dCDR into the iCDR&#x20;

The interfaces which differentiated the iCDR and dCDR have now been combined into a common platform. This completes the refactoring of Portable Class Library code to a common code base. This means that any iCDR code can run (theoretically) in a dCDR or vice versa. It also means that iCDRs can be synchronized with other iCDR instances.

## Better Development Tools

The development of applets has been greatly improved with the new `SanteDB.DevTools` package. This plugin allows the iCDR to act like the applet debugger in the v2 iCDR. Meaning that you can edit BI reports, business rules, etc. directly in Visual Studio Code and your iCDR instance will load them in real time.

